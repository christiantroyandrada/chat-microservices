name: CI Pipeline[main]

on:
  push:
    branches: [main]

# Give this workflow the permissions required by called reusable workflows
# `security-audit.yml` requests `security-events: write`, so we must allow it here.
permissions:
  contents: read
  security-events: write

jobs:
  build:
    name: Build & Audit
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [22.x]

    steps:
      - name: Checkout
        # Pinned to specific commit SHA for supply-chain security
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Use Node.js ${{ matrix.node-version }}
        # Pinned to specific commit SHA for supply-chain security
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020
        with:
          node-version: ${{ matrix.node-version }}

      - name: Build user-service
        working-directory: ./user-service
        run: |
          npm ci
          npm run build

      - name: Build chat-service
        working-directory: ./chat-service
        run: |
          npm ci
          npm run build

      - name: Build notification-service
        working-directory: ./notification-service
        run: |
          npm ci
          npm run build

      - name: Audit backends
        run: |
          npm audit --prefix user-service --audit-level=moderate || true
          npm audit --prefix chat-service --audit-level=moderate || true
          npm audit --prefix notification-service --audit-level=moderate || true

      - name: Summary
        run: echo "Backend Build completed successfully"

  # TypeScript type checking (runs for all branches)
  typescript-check:
    name: TypeScript Type Check
    needs: build
    uses: ./.github/workflows/typescript-check.yml

  # Security audit (only runs on main branch)
  security-audit:
    name: Security Audit
    needs: typescript-check
    if: github.ref == 'refs/heads/main' || github.event_name == 'schedule'
    uses: ./.github/workflows/security-audit.yml
    secrets: inherit

  # Unit tests with coverage (only runs on main branch)
  unit-tests:
    name: Unit Tests & Coverage
    needs: security-audit
    if: github.ref == 'refs/heads/main'
    uses: ./.github/workflows/unit-tests.yml
    with:
      coverage: 'true'
    secrets: inherit

  # Deploy to VPS (only runs on main branch after tests pass)
  deploy:
    name: Deploy to VPS
    needs: unit-tests
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    concurrency:
      group: production-deployment
      cancel-in-progress: false

    steps:
      - name: Fetch secrets from Infisical
        id: infisical
        uses: Infisical/secrets-action@v1.0.7
        with:
          method: universal
          # Intentional  misspelling as INFISICAL was erroneously created in secrets
          client-id: ${{ secrets.INFISCAL_CLIENT_ID }}
          client-secret: ${{ secrets.INFISCAL_CLIENT_SECRET }}
          project-slug: ${{ secrets.INFISCAL_PROJECT_SLUG }}
          env-slug: prod
          secret-path: /

      - name: Validate Infisical secrets
        run: |
          echo "ğŸ” Validating required secrets from Infisical..."
          MISSING=0
          
          # Infisical action sets secrets as environment variables, not outputs
          # Check each required secret using env context (do not print values)
          if [ -z "$ADMIN_USERNAME" ]; then
            echo "âŒ ADMIN_USERNAME is missing or empty in Infisical"
            MISSING=1
          else
            echo "âœ… ADMIN_USERNAME present"
          fi
          
          if [ -z "$ADMIN_PASSWORD" ]; then
            echo "âŒ ADMIN_PASSWORD is missing or empty in Infisical"
            MISSING=1
          else
            echo "âœ… ADMIN_PASSWORD present"
          fi
          
          if [ -z "$ADMIN_PASSWORD_ENCODED" ]; then
            echo "âŒ ADMIN_PASSWORD_ENCODED is missing or empty in Infisical"
            MISSING=1
          else
            echo "âœ… ADMIN_PASSWORD_ENCODED present"
          fi
          
          if [ -z "$CORS_ORIGINS" ]; then
            echo "âš ï¸  CORS_ORIGINS is missing or empty in Infisical (may be intentional)"
          else
            echo "âœ… CORS_ORIGINS present"
          fi
          
          if [ -z "$MESSAGE_BROKER_URL" ]; then
            echo "âš ï¸  MESSAGE_BROKER_URL is missing or empty in Infisical (may be intentional)"
          else
            echo "âœ… MESSAGE_BROKER_URL present"
          fi
          
          if [ "$MISSING" -eq 1 ]; then
            echo ""
            echo "âŒ One or more required secrets are missing in Infisical."
            echo "Please verify in Infisical dashboard:"
            echo "  - Project: ${{ secrets.INFISCAL_PROJECT_SLUG }}"
            echo "  - Environment: prod"
            echo "  - Path: /"
            echo ""
            echo "Ensure these secrets exist and have values:"
            echo "  - ADMIN_USERNAME (PostgreSQL username)"
            echo "  - ADMIN_PASSWORD (PostgreSQL password)"
            echo "  - ADMIN_PASSWORD_ENCODED (URL-encoded version)"
            exit 1
          fi
          
          echo "âœ… All required secrets validated"

      - name: Debug SSH connectivity (temporary)
        if: always()
        continue-on-error: true
        run: |
          echo "ğŸ” Debugging SSH connectivity to VPS (safe, will not expose key)"
          # Check whether the secret exists (do not print the secret itself)
          if [ -z "${{ secrets.VPS_SSH_PRIVATE_KEY }}" ]; then
            echo "âŒ Secret 'VPS_SSH_PRIVATE_KEY' is missing or empty"
            echo "Please confirm the secret exists in repository settings or organization secrets."
            exit 0
          else
            echo "âœ… Secret 'VPS_SSH_PRIVATE_KEY' appears present"
          fi

          # Write the private key to a temporary file and attempt a verbose auth
          mkdir -p /tmp/ssh-debug
          PRIVATE_KEY="${{ secrets.VPS_SSH_PRIVATE_KEY }}"
          printf '%s\n' "$PRIVATE_KEY" > /tmp/ssh-debug/deploy_key
          chmod 600 /tmp/ssh-debug/deploy_key

          echo "Attempting SSH handshake (will continue on failure)..."
          ssh -i /tmp/ssh-debug/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -p "${{ secrets.VPS_PORT || '22' }}" \
            "${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}" echo "SSH_OK" || true

      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@029f5b4aeeeb58fdfe1410a5d17f967dacf36262
        env:
          # Database credentials (Infisical sets these as env vars, pass them through)
          ADMIN_USERNAME: ${{ env.ADMIN_USERNAME }}
          ADMIN_PASSWORD: ${{ env.ADMIN_PASSWORD }}
          ADMIN_PASSWORD_ENCODED: ${{ env.ADMIN_PASSWORD_ENCODED }}
          # Application secrets
          CORS_ORIGINS: ${{ env.CORS_ORIGINS }}
          MESSAGE_BROKER_URL: ${{ env.MESSAGE_BROKER_URL }}
          SENDINBLUE_APIKEY: ${{ env.SENDINBLUE_APIKEY }}
          SMTP_PASS: ${{ env.SMTP_PASS }}
          SMTP_USER: ${{ env.SMTP_USER }}
          # Deployment config
          PGADMIN_EMAIL: ${{ secrets.PGADMIN_EMAIL || 'admin@admin.com' }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT || '22' }}
          command_timeout: 30m
          envs: ADMIN_USERNAME,ADMIN_PASSWORD,ADMIN_PASSWORD_ENCODED,CORS_ORIGINS,MESSAGE_BROKER_URL,SENDINBLUE_APIKEY,SMTP_PASS,SMTP_USER,PGADMIN_EMAIL
          script: |
            set -euo pipefail
            export DEPLOY_PATH="${{ secrets.DEPLOY_PATH || '/opt/chat-app' }}"

            echo "ğŸš€ Starting backend deployment..."

            # Ensure DEPLOY_PATH is writable; fall back to $HOME if needed
            if ! mkdir -p "$DEPLOY_PATH" 2>/dev/null; then
              echo "âš ï¸ Cannot create $DEPLOY_PATH (permission denied). Falling back to home directory"
              FALLBACK="$HOME/chat-app"
              mkdir -p "$FALLBACK"
              export DEPLOY_PATH="$FALLBACK"
              echo "â¡ï¸ Using fallback DEPLOY_PATH=$DEPLOY_PATH"
            fi

            # If the chat-microservices directory exists, update it. Otherwise try to clone it.
            if [ -d "$DEPLOY_PATH/chat-microservices" ]; then
              echo "â¡ï¸ Found existing directory $DEPLOY_PATH/chat-microservices â€” updating"
              cd "$DEPLOY_PATH/chat-microservices"
              # Try to fetch from origin; fall back to pull if fetch fails
              if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
                git fetch origin --prune || git pull --rebase --autostash || true
                git reset --hard origin/main || true
              else
                echo "âš ï¸ Directory exists but is not a git repo â€” attempting to re-clone"
                cd "$DEPLOY_PATH"
                rm -rf chat-microservices
                # Fall through to clone step below
              fi
            fi

            if [ ! -d "$DEPLOY_PATH/chat-microservices" ]; then
              echo "â¡ï¸ Directory not found â€” creating $DEPLOY_PATH and attempting to clone repository"
              mkdir -p "$DEPLOY_PATH"
              cd "$DEPLOY_PATH"

              REPO_URL="https://github.com/${{ github.repository }}.git"
              # Try a shallow clone (may fail for private repos)
              if git ls-remote --exit-code "$REPO_URL" >/dev/null 2>&1; then
                git clone --depth 1 --branch main "$REPO_URL" chat-microservices || {
                  echo "âš ï¸ git clone failed, creating empty folder to continue"
                  mkdir -p chat-microservices
                }
                cd chat-microservices || true
              else
                echo "âš ï¸ Cannot access $REPO_URL (network or permissions). Creating empty directory and continuing"
                mkdir -p chat-microservices
                cd chat-microservices
              fi
            fi

            cd "$DEPLOY_PATH/chat-microservices"

            # Check Docker permissions
            echo "ğŸ” Checking Docker permissions..."
            if ! docker ps >/dev/null 2>&1; then
              echo "âš ï¸ Docker permission denied. Attempting to add user to docker group..."
              # Check if user is in docker group
              if ! groups | grep -q docker; then
                echo "ğŸ’¡ User is not in docker group. To fix this on VPS, run:"
                echo "   sudo usermod -aG docker $USER && newgrp docker"
                echo "âš ï¸ Continuing anyway - docker commands may fail"
              fi
            else
              echo "âœ… Docker access confirmed"
            fi

            # Ensure docker-secrets directory and app_secrets file exist
            echo "ğŸ”§ Ensuring docker-secrets/app_secrets exists..."
            mkdir -p docker-secrets
            if [ ! -f docker-secrets/app_secrets ]; then
              echo "â¡ï¸ Creating docker-secrets/app_secrets from environment variables"
              cat > docker-secrets/app_secrets <<EOF
            ADMIN_USERNAME=${ADMIN_USERNAME}
            ADMIN_PASSWORD=${ADMIN_PASSWORD}
            ADMIN_PASSWORD_ENCODED=${ADMIN_PASSWORD_ENCODED}
            CORS_ORIGINS=${CORS_ORIGINS}
            MESSAGE_BROKER_URL=${MESSAGE_BROKER_URL}
            SENDINBLUE_APIKEY=${SENDINBLUE_APIKEY}
            SMTP_PASS=${SMTP_PASS}
            SMTP_USER=${SMTP_USER}
            PGADMIN_EMAIL=${PGADMIN_EMAIL}
            EOF
              echo "âœ… Created docker-secrets/app_secrets"
            else
              echo "âœ… docker-secrets/app_secrets already exists"
            fi

            # Ensure deploy script exists before trying to run it
            if [ -f deploy/deploy-vps.sh ]; then
              echo "ğŸ”§ Making deploy script executable and running it"
              chmod +x deploy/deploy-vps.sh || true
              # Export all environment variables so deploy-vps.sh can access them
              export ADMIN_USERNAME
              export ADMIN_PASSWORD
              export ADMIN_PASSWORD_ENCODED
              export PGADMIN_EMAIL
              export CORS_ORIGINS
              export MESSAGE_BROKER_URL
              export SENDINBLUE_APIKEY
              export SMTP_PASS
              export SMTP_USER
              bash deploy/deploy-vps.sh
            else
              echo "âš ï¸ deploy/deploy-vps.sh not found â€” skipping script run"
              echo "ğŸ“ Current directory listing:"
              ls -la || true
            fi

      - name: Verify deployment
        uses: appleboy/ssh-action@029f5b4aeeeb58fdfe1410a5d17f967dacf36262
        env:
          # Database credentials (Infisical sets these as env vars, pass them through)
          ADMIN_USERNAME: ${{ env.ADMIN_USERNAME }}
          ADMIN_PASSWORD: ${{ env.ADMIN_PASSWORD }}
          ADMIN_PASSWORD_ENCODED: ${{ env.ADMIN_PASSWORD_ENCODED }}
          # Application secrets
          CORS_ORIGINS: ${{ env.CORS_ORIGINS }}
          MESSAGE_BROKER_URL: ${{ env.MESSAGE_BROKER_URL }}
          SENDINBLUE_APIKEY: ${{ env.SENDINBLUE_APIKEY }}
          SMTP_PASS: ${{ env.SMTP_PASS }}
          SMTP_USER: ${{ env.SMTP_USER }}
          # Deployment config
          PGADMIN_EMAIL: ${{ secrets.PGADMIN_EMAIL || 'admin@admin.com' }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT || '22' }}
          envs: ADMIN_USERNAME,ADMIN_PASSWORD,ADMIN_PASSWORD_ENCODED,CORS_ORIGINS,MESSAGE_BROKER_URL,SENDINBLUE_APIKEY,SMTP_PASS,SMTP_USER,PGADMIN_EMAIL
          script: |
            set -e
            export DEPLOY_PATH="${{ secrets.DEPLOY_PATH || '/opt/chat-app' }}"
            
            # Export all environment variables for docker compose
            export ADMIN_USERNAME
            export ADMIN_PASSWORD
            export ADMIN_PASSWORD_ENCODED
            export PGADMIN_EMAIL
            export CORS_ORIGINS
            export MESSAGE_BROKER_URL
            export SENDINBLUE_APIKEY
            export SMTP_PASS
            export SMTP_USER
            
            cd $DEPLOY_PATH/chat-microservices
            
            echo "â³ Waiting for services to be healthy..."
            sleep 15
            
            # Check service status
            docker compose ps
            
            # Check if all critical services are healthy
            if docker compose ps | grep -E '(user|chat|notification|frontend|nginx)' | grep -q "unhealthy"; then
              echo "âŒ Some services are unhealthy!"
              echo "ğŸ“‹ Service status:"
              docker compose ps
              echo "ğŸ“ Recent logs:"
              docker compose logs --tail=50
              exit 1
            fi
            
            # Test health endpoints
            echo "ğŸ” Testing health endpoints..."
            curl -f http://localhost:80/health || (echo "âŒ NGINX health check failed" && exit 1)
            
            echo "âœ… All services are running and healthy"
            echo "ğŸ‰ Backend deployment successful!"

      - name: Cleanup after deployment
        if: success()
        uses: appleboy/ssh-action@029f5b4aeeeb58fdfe1410a5d17f967dacf36262
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT || '22' }}
          script: |
            echo "ğŸ§¹ Running post-deployment cleanup..."
            DEPLOY_PATH="/opt/chat-app"
            cd $DEPLOY_PATH/chat-microservices
            
            # Prune dangling images (unused layers from previous builds)
            echo "ğŸ—‘ï¸ Pruning dangling Docker images..."
            docker image prune -f || true
            
            # Prune stopped containers (if any)
            echo "ğŸ—‘ï¸ Pruning stopped containers..."
            docker container prune -f || true
            
            # Prune unused volumes (careful - only anonymous volumes)
            echo "ğŸ—‘ï¸ Pruning unused anonymous volumes..."
            docker volume prune -f --filter "label!=keep" || true
            
            # Prune unused networks
            echo "ğŸ—‘ï¸ Pruning unused networks..."
            docker network prune -f || true
            
            # Show disk usage after cleanup
            echo "ğŸ“Š Docker disk usage after cleanup:"
            docker system df
            
            echo "âœ… Cleanup complete!"

