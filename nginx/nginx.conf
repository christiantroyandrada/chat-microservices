events {}

http {
  resolver 127.0.0.11 valid=30s ipv6=off;

  # Nice-to-haves
  tcp_nodelay on;            # reduce small-packet latency
  client_max_body_size 20m;  # adjust as needed
  keepalive_requests 1000;   # allow many requests per kept-alive connection

  upstream user {
    zone user 64k;
    server user:8081 resolve;
    keepalive 16;
  }

  upstream chat {
    zone chat 64k;
    server chat:8082 resolve;
    keepalive 16;
  }

  upstream notification {
    zone notification 64k;
    server notification:8083 resolve;
    keepalive 16;
  }

  # Frontend SvelteKit server (containerized)
  upstream frontend {
    zone frontend 64k;
    server frontend:3000 resolve;
    keepalive 16;
  }

  server {
    # Non-root user can't bind to privileged ports (<1024), use 8080
    listen 8080;

    # Global proxy/forward headers (preserve upstream keepalive)
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host  $host;
    proxy_set_header Connection        "";

    # No CORS handling here â€” CORS will be handled by each service at the application level.

    proxy_connect_timeout 5s;
    proxy_send_timeout    60s;
    proxy_read_timeout    60s;

    proxy_next_upstream       error timeout http_502 http_503 http_504;
    proxy_next_upstream_tries 3;

    # ---- /health (nginx health check) ----
    location /health {
      access_log off;
      return 200 '{"status":"ok","service":"nginx-gateway"}';
      add_header Content-Type application/json;
    }

    # ---- / (root) - Frontend (SvelteKit dev server) ----
    # Proxy all unmatched requests to the frontend dev server
    # ---- /api/user (REST API for user service) ----
    # This handles /api/user/prekeys and other /api/user/* endpoints
    # MUST come before the / location to match correctly
    location /api/user/ {
      proxy_pass http://user/;
      proxy_request_buffering on;
    }

    # ---- /user (REST) ----
    location /user/ {
      proxy_pass http://user/;
      proxy_request_buffering on;
    }

    # This must be LAST so API routes are matched first
    location / {
      proxy_pass http://frontend;
      proxy_http_version 1.1;
      proxy_set_header Connection "";
    }

    # ---- /notifications (REST) ----
    # Support both /notification/ and /notifications/ prefixes to avoid
    # brittle mismatches between frontend and gateway during migration.
    # Forward both /notification/ and /notifications/ to the notification service
    # but proxy to the canonical `/notifications/` mount on the service
    location /notification/ {
      proxy_pass http://notification/notifications/;
      proxy_request_buffering on;
    }

    location /notifications/ {
      proxy_pass http://notification/notifications/;
      proxy_request_buffering on;
    }

    # ---- /chat (REST, non-socket.io) ----
    location /chat/ {
      proxy_pass http://chat/;
      proxy_request_buffering on;
    }

    # Socket.IO path (polling + websocket)
    location ~* ^/chat/socket\.io/ {
    
      # OPTIONAL: short-circuit OPTIONS without adding CORS headers.
      # The app will add CORS on real requests; preflights get a quick 204.
      if ($request_method = OPTIONS) {
        return 204;
      }
    
      proxy_pass http://chat;
      proxy_request_buffering off;
      proxy_buffering off;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      # Forward cookies so Socket.IO server can read httpOnly JWT from handshake headers
      proxy_set_header Cookie $http_cookie;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_read_timeout 1h;
      proxy_send_timeout 1h;
    }
  }
}
