events {
  worker_connections 1024;
}

http {
  resolver 127.0.0.11 valid=30s ipv6=off;

  # ---- Performance ----
  tcp_nodelay on;            # reduce small-packet latency
  tcp_nopush on;             # optimize packet batching with sendfile
  client_max_body_size 20m;  # adjust as needed
  keepalive_requests 1000;   # allow many requests per kept-alive connection

  # ---- Gzip Compression ----
  gzip on;
  gzip_vary on;
  gzip_proxied any;
  gzip_comp_level 4;
  gzip_min_length 256;
  gzip_types
    text/plain
    text/css
    text/xml
    text/javascript
    application/json
    application/javascript
    application/xml
    application/xml+rss
    image/svg+xml;

  # ---- Rate Limiting Zones ----
  # Global rate limit: 30 requests/sec per IP (burst allows short spikes)
  limit_req_zone $binary_remote_addr zone=global:10m rate=30r/s;
  # Auth endpoints: stricter limit - 5 requests/sec per IP
  limit_req_zone $binary_remote_addr zone=auth:10m rate=5r/s;
  # WebSocket connections: 10 per second per IP
  limit_req_zone $binary_remote_addr zone=websocket:10m rate=10r/s;

  # Return 429 Too Many Requests instead of default 503
  limit_req_status 429;

  # ---- Security: Hide nginx version ----
  server_tokens off;

  upstream user {
    zone user 64k;
    server user:8081 resolve;
    keepalive 16;
  }

  upstream chat {
    zone chat 64k;
    server chat:8082 resolve;
    keepalive 16;
  }

  upstream notification {
    zone notification 64k;
    server notification:8083 resolve;
    keepalive 16;
  }

  # Frontend SvelteKit server (containerized)
  # Note: frontend may not be available on VPS-only deployments (uses profile)
  # nginx will return 502 if frontend is down, which is handled gracefully
  upstream frontend {
    zone frontend 64k;
    server frontend:3000 resolve;
    keepalive 16;
  }

  server {
    # Non-root user can't bind to privileged ports (<1024), use 8080
    listen 8080;

    # ---- Security Headers (applied to all responses) ----
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "0" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;
    # Content-Security-Policy: restrictive default, allow self + websocket
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self' ws: wss:; img-src 'self' data:; font-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self'" always;

    # ---- Global Rate Limit ----
    limit_req zone=global burst=60 nodelay;

    # Global proxy/forward headers (preserve upstream keepalive)
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host  $host;
    proxy_set_header Connection        "";

    # No CORS handling here â€” CORS will be handled by each service at the application level.

    proxy_connect_timeout 5s;
    proxy_send_timeout    60s;
    proxy_read_timeout    60s;

    proxy_next_upstream       error timeout http_502 http_503 http_504;
    proxy_next_upstream_tries 3;

    # ---- /health (nginx health check) ----
    location /health {
      access_log off;
      return 200 '{"status":"ok","service":"nginx-gateway"}';
      add_header Content-Type application/json;
    }

    # ---- / (root) - Frontend (SvelteKit dev server) ----
    # Proxy all unmatched requests to the frontend dev server
    # ---- /api/user (REST API for user service) ----
    # This handles /api/user/prekeys and other /api/user/* endpoints
    # MUST come before the / location to match correctly
    location /api/user/ {
      proxy_pass http://user/;
      proxy_request_buffering on;
    }

    # ---- Auth endpoints with stricter rate limiting ----
    location ~ ^/user/(register|login)$ {
      limit_req zone=auth burst=10 nodelay;
      proxy_pass http://user;
      proxy_request_buffering on;
    }

    # ---- /user (REST) ----
    location /user/ {
      proxy_pass http://user/;
      proxy_request_buffering on;
    }

    # This must be LAST so API routes are matched first
    # If frontend is not running (VPS-only deployment), nginx will return error
    # which signals to users that API is available but frontend is not deployed here
    location / {
      proxy_pass http://frontend;
      proxy_http_version 1.1;
      proxy_set_header Connection "";
      # Short timeout for frontend - if it's not running, fail fast
      proxy_connect_timeout 2s;
      proxy_read_timeout 5s;
      # Return a helpful JSON message if frontend is unavailable
      proxy_intercept_errors on;
      error_page 502 503 504 = @frontend_unavailable;
    }

    # Fallback when frontend is not available
    location @frontend_unavailable {
      default_type application/json;
      return 200 '{"status":"ok","message":"API server running. Frontend is not deployed on this server. API endpoints: /api/user/*, /user/*, /chat/*, /notifications/*","health":"/health"}';
    }

    # ---- /notifications (REST) ----
    # Support both /notification/ and /notifications/ prefixes to avoid
    # brittle mismatches between frontend and gateway during migration.
    # Forward both /notification/ and /notifications/ to the notification service
    # but proxy to the canonical `/notifications/` mount on the service
    location /notification/ {
      proxy_pass http://notification/notifications/;
      proxy_request_buffering on;
    }

    location /notifications/ {
      proxy_pass http://notification/notifications/;
      proxy_request_buffering on;
    }

    # ---- /chat (REST, non-socket.io) ----
    location /chat/ {
      proxy_pass http://chat/;
      proxy_request_buffering on;
    }

    # Socket.IO path (polling + websocket)
    location ~* ^/chat/socket\.io/ {
    
      # Rate limit WebSocket connection upgrades
      limit_req zone=websocket burst=20 nodelay;

      # OPTIONAL: short-circuit OPTIONS without adding CORS headers.
      # The app will add CORS on real requests; preflights get a quick 204.
      if ($request_method = OPTIONS) {
        return 204;
      }
    
      proxy_pass http://chat;
      proxy_request_buffering off;
      proxy_buffering off;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      # Forward cookies so Socket.IO server can read httpOnly JWT from handshake headers
      proxy_set_header Cookie $http_cookie;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_read_timeout 1h;
      proxy_send_timeout 1h;
    }
  }
}
